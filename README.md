# kubernetes-podcertificate-signer

kubernetes-podcertificate-signerCustom is a custom controller for generating certificates based on the requests generated by pods. It is an early stage development and due to the feature being in alpha does required to enable feature flags and customisation of the runtime. 

# TODOs: 
[ ] signer check if  it doesn't support the key type of publicKey
[ ] tests
[ ] e2e
[ ] Default certificate length on the controller arguments
[ ] Object consistency Camel/Snake casing
[ ] Consider the case where we have pod subdomain specified and also hostname as FQDN
[ ] Customizable Key Usage via Policies
[ ] Customizable Ext Key Usage via Policies or other aliases i.e. client-server-auth , ssl ,

# Setup 
```
clean dependency flow: signer → authority → podcertificate
```

## Default certificate configuration
ExtKeyUsageServerAuth: Allows the certificate to act as a server (other pods can verify it)
ExtKeyUsageClientAuth: Allows the certificate to act as a client (it can authenticate to other pods)
KeyUsageKeyEncipherment: Enables encryption of the TLS session
KeyUsageDigitalSignature: Enables signing of the TLS handshake messages

## mTLS aspect 
```
Client Pod                    Server Pod
    |                             |
    |-----> Client Cert + Key --->|  (Client sends its certificate)
    |<---- Server Cert + Key -----|  (Server sends its certificate)
    |                             |
```

Zero Trust: Pods don't trust each other by default
Identity Verification: Each pod proves its identity
Encrypted Communication: All traffic is encrypted
Audit Trail: You can track which pod talked to which pod
Network Policies: Can be combined with Kubernetes NetworkPolicies

# Setup kind for testing
The easiest way to run the contoller is to use `kind` and create a small cluster that would be used to simulation of the setup.

## Sample kind configuration 
For simple testing the following configuration can be used to spin up a test cluster.
```
---
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
featureGates:
  "PodCertificateRequest": true # For Pod generated certificates
  "ImageVolume": true # For mounting OCI volumes
  "StructuredAuthenticationConfiguration": true
  "MutatingAdmissionPolicy": true # https://kubernetes.io/docs/reference/access-authn-authz/mutating-admission-policy/
runtimeConfig:
  "certificates.k8s.io/v1alpha1/podcertificaterequests": "true" # For Pod generated certificates
  "admissionregistration.k8s.io/v1beta1": "true" # For MutatingAdmissionPolicy
containerdConfigPatches:
- |-
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."gitea.raftech.localtest.me:8443"]
    endpoint = ["https://gitea.raftech.localtest.me"]
  [plugins."io.containerd.grpc.v1.cri".registry.configs."gitea.cnoe.localtest.me".tls]
    insecure_skip_verify = true
nodes:
- role: control-plane
  image: "kindest/node:v1.34.0"
  labels:
    ingress-ready: "true"
  extraPortMappings:
  - containerPort: 443
    hostPort: 8443
    protocol: TCP
  - containerPort: 32222
    hostPort: 32222
    protocol: TCP  
```

## Controller and its configuration
The controller is currently

## Sample deployment
The following can be used to create a deployment which will trigger new PodCertificateRequests to be issued by the kube-api
```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: duo-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: podcertificate-app
  template:
    metadata:
      labels:
        app: podcertificate-app
      annotations:
        coolcert.example.com/foo-cn: "some-epic-name.com"
        coolcert.example.com/foo-san: "example.com, www.example.com, anotherexample.com.cy"
        coolcert.example.com/foo-duration: "2h"
        coolcert.example.com/foo-refresh: "30m" 
        coolcert.example.com/foo-uris: "https://example.com, https://www.example.com, https://anotherexample.com.cy"                
    spec:
      serviceAccountName: default
      containers:
      - image: debian
        name: main
        command: ["sleep", "infinity"]
        volumeMounts:
        - name: my-x509-credentials
          mountPath: /var/run/my-x509-credentials
      volumes:
      - name: my-x509-credentials
        projected:
          defaultMode: 420
          sources:
          - podCertificate:
              keyType: ED25519
              signerName: coolcert.example.com/foo
              credentialBundlePath: credentialbundle.pem
```


## Development in progress 

```sh
kubebuilder init --domain=operators.raftech.io --repo=github.com/rafpe/kubernetes-podcertificate-signer --project-name podcert
kubebuilder create api --group certificates --version v1alpha1 --kind PodCertificateRequest --controller --resource=false
```


## To Requeue or not 

```
			// DON'T REQUEUE - Terminal success
			return ctrl.Result{}, nil
		
			// DON'T REQUEUE - Terminal failure (log error but don't retry)
			if terminalError {
				r.Log.Error(err, "Terminal error - not retrying")
				return ctrl.Result{}, nil // nil error = no requeue
			}
		
			// REQUEUE - Transient error (will retry with exponential backoff)
			return ctrl.Result{}, fmt.Errorf("transient error: %w", err)
		
			// REQUEUE AFTER SPECIFIC TIME - Scheduled retry
			return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil
```


## Development ideas for later 

### Add custom OIDs 
Would require a lot of work to get official OIDs registered - but long term run would be amazing to have a dedicatd Kubernetes OIDs registered

### Add to certificate pod/cluster metadata via Enhanced Subject  
This approach would use something like 

```
template := &x509.Certificate{
    // ... existing fields ...
    Subject: pkix.Name{
        // Primary identity
        CommonName: "my-pod.default.svc.cluster.local",
        
        // Organizational structure
        Organization:       []string{"kubernetes.io"},
        OrganizationalUnit: []string{"pods", "default"},
        
        // Geographic information
        Country:      []string{"US"},
        Province:     []string{"Kubernetes"},
        Locality:     []string{"Cluster"},
        StreetAddress: []string{"10.244.0.0/16"}, // Pod network
        PostalCode:   []string{"k8s-001"},
    },
}
```

Could build functions around it like 
```
func buildKubernetesSubject(config *podcertificate.PodCertificateConfig) pkix.Name {
    return pkix.Name{
        // Primary identity - follows Kubernetes naming conventions
        CommonName: fmt.Sprintf("%s.%s.svc.cluster.local", 
            config.PodName, config.Namespace),
        
        // Organizational hierarchy
        Organization: []string{
            "kubernetes.io",
            "cluster.local",
        },
        OrganizationalUnit: []string{
            "pods",
            config.Namespace,
            config.NodeName, // Node affinity
        },
        
        // Geographic/Logical location
        Country:      []string{"K8S"}, // Kubernetes identifier
        Province:     []string{config.Namespace},
        Locality:     []string{config.NodeName},
        StreetAddress: []string{config.PodIP},
        PostalCode:   []string{config.UID},
    }
}

func (ca *CertificateAuthority) buildEnhancedSubject(config *podcertificate.PodCertificateConfig) pkix.Name {
    // Build comprehensive subject information
    subject := pkix.Name{
        CommonName: ca.buildCommonName(config),
        Organization: ca.buildOrganizations(config),
        OrganizationalUnit: ca.buildOrganizationalUnits(config),
        Country: ca.buildCountries(config),
        Province: ca.buildProvinces(config),
        Locality: ca.buildLocalities(config),
        StreetAddress: ca.buildStreetAddresses(config),
        PostalCode: ca.buildPostalCodes(config),
    }
    
    return subject
}

func (ca *CertificateAuthority) buildCommonName(config *podcertificate.PodCertificateConfig) string {
    // Priority order for CommonName
    if config.ServiceName != "" {
        return fmt.Sprintf("%s.%s.svc.cluster.local", 
            config.ServiceName, config.Namespace)
    }
    return fmt.Sprintf("%s.%s.pod.cluster.local", 
        config.PodName, config.Namespace)
}

func (ca *CertificateAuthority) buildOrganizations(config *podcertificate.PodCertificateConfig) []string {
    orgs := []string{"kubernetes.io"}
    
    // Add cluster-specific organization
    if clusterName := config.Annotations["cluster.kubernetes.io/cluster-name"]; clusterName != "" {
        orgs = append(orgs, clusterName)
    }
    
    // Add environment-specific organization
    if env := config.Labels["environment"]; env != "" {
        orgs = append(orgs, fmt.Sprintf("env-%s", env))
    }
    
    return orgs
}

func (ca *CertificateAuthority) buildOrganizationalUnits(config *podcertificate.PodCertificateConfig) []string {
    ous := []string{"pods"}
    
    // Add namespace as OU
    if config.Namespace != "" {
        ous = append(ous, config.Namespace)
    }
    
    // Add node as OU for node affinity
    if config.NodeName != "" {
        ous = append(ous, fmt.Sprintf("node-%s", config.NodeName))
    }
    
    // Add service as OU if available
    if config.ServiceName != "" {
        ous = append(ous, fmt.Sprintf("service-%s", config.ServiceName))
    }
    
    // Add security context as OU
    if config.RunAsUser != nil {
        ous = append(ous, fmt.Sprintf("user-%d", *config.RunAsUser))
    }
    
    return ous
}

func (ca *CertificateAuthority) buildCountries(config *podcertificate.PodCertificateConfig) []string {
    countries := []string{"K8S"} // Kubernetes identifier
    
    // Add environment as country code
    if env := config.Labels["environment"]; env != "" {
        countries = append(countries, strings.ToUpper(env[:2]))
    }
    
    return countries
}

func (ca *CertificateAuthority) buildProvinces(config *podcertificate.PodCertificateConfig) []string {
    provinces := []string{config.Namespace}
    
    // Add zone/region information
    if zone := config.Labels["topology.kubernetes.io/zone"]; zone != "" {
        provinces = append(provinces, zone)
    }
    
    return provinces
}

func (ca *CertificateAuthority) buildLocalities(config *podcertificate.PodCertificateConfig) []string {
    localities := []string{config.NodeName}
    
    // Add node zone information
    if nodeZone := config.Labels["topology.kubernetes.io/zone"]; nodeZone != "" {
        localities = append(localities, nodeZone)
    }
    
    return localities
}

func (ca *CertificateAuthority) buildStreetAddresses(config *podcertificate.PodCertificateConfig) []string {
    addresses := []string{config.PodIP}
    
    // Add service IP if available
    if serviceIP := config.Annotations["service.kubernetes.io/service-ip"]; serviceIP != "" {
        addresses = append(addresses, serviceIP)
    }
    
    return addresses
}

func (ca *CertificateAuthority) buildPostalCodes(config *podcertificate.PodCertificateConfig) []string {
    codes := []string{config.UID}
    
    // Add pod creation timestamp as postal code
    if creationTime := config.Annotations["kubernetes.io/created-at"]; creationTime != "" {
        codes = append(codes, creationTime)
    }
    
    return codes
}

```

```
Subject: CN=my-service.default.svc.cluster.local
         O=kubernetes.io
         O=my-cluster
         O=env-production
         OU=pods
         OU=default
         OU=node-worker-1
         OU=service-my-service
         OU=user-1000
         C=K8S
         C=PR
         ST=default
         ST=us-west-1a
         L=worker-1
         L=us-west-1a
         streetAddress=10.244.1.5
         streetAddress=10.96.0.1
         postalCode=abc123-def456-ghi789
         postalCode=2024-01-15T10:30:00Z
```